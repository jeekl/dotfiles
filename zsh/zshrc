# Path to zsh configuration.
#export ZSH=$HOME/.config/dotfiles/zsh
export ZSH=$HOME/.zsh
fpath=(
    $ZSH/functions
    $ZSH/completion
    $fpath
)
# Load rest of configuration
for config_file ($ZSH/*.zsh) source $config_file

# check for user, if not running as root set $SUDO to sudo
(( EUID != 0 )) && SUDO='sudo' || SUDO=''
(( EUID != 0 )) && umask 002 || umask 022

# Load is-at-least() for more precise version checks
# Note that this test will *always* fail, if the is-at-least
# function could not be marked for autoloading.
zrcautoload is-at-least || is-at-least() { return 1 }


setopt append_history       # append history list to the history file (important for multiple parallel zsh sessions!)
is4 && setopt SHARE_HISTORY # import new commands from the history file also in other zsh-session
setopt extended_history     # save each command's beginning timestamp and the duration to the history file
is4 && setopt histignorealldups # If  a  new  command  line being added to the history
                            # list duplicates an older one, the older command is removed from the list
setopt histignorespace      # remove command lines from the history list when
                            # the first character on the line is a space
setopt auto_cd              # if a command is issued that can't be executed as a normal command,
                            # and the command is the name of a directory, perform the cd command to that directory
setopt extended_glob        # in order to use #, ~ and ^ for filename generation
                            # grep word *~(*.gz|*.bz|*.bz2|*.zip|*.Z) ->
                            # -> searches for word not in compressed files
                            # don't forget to quote '^', '~' and '#'!
setopt longlistjobs         # display PID when suspending processes as well
setopt notify               # report the status of backgrounds jobs immediately
setopt hash_list_all        # Whenever a command completion is attempted, make sure \
                            # the entire command path is hashed first.
setopt completeinword       # not just at the end
setopt nohup                # and don't kill them, either
setopt auto_pushd           # make cd push the old directory onto the directory stack.
setopt nonomatch            # try to avoid the 'zsh: no matches found...'
setopt nobeep               # avoid "beep"ing
setopt pushd_ignore_dups    # don't push the same dir twice.
setopt noglobdots           # * shouldn't match dotfiles. ever.
setopt noshwordsplit        # use zsh style word splitting
setopt unset                # don't error out when unset parameters are used

# setting some default values

NOCOR=${NOCOR:-0}
NOMENU=${NOMENU:-0}
NOPRECMD=${NOPRECMD:-0}
COMMAND_NOT_FOUND=${COMMAND_NOT_FOUND:-0}
BATTERY=${BATTERY:-0}
ZSH_NO_DEFAULT_LOCALE=${ZSH_NO_DEFAULT_LOCALE:-0}

# locale setup
if (( ZSH_NO_DEFAULT_LOCALE == 0 )); then
    xsource "/etc/default/locale"
fi
for var in LANG LC_ALL LC_MESSAGES ; do
    [[ -n ${(P)var} ]] && export $var
done
xsource "/etc/sysconfig/keyboard"
TZ=$(xcat /etc/timezone)

# set some variables
if check_com -c vim ; then
    export EDITOR=${EDITOR:-vim}
else
    export EDITOR=${EDITOR:-vi}
fi
export PAGER=${PAGER:-less}
export MAIL=${MAIL:-/var/mail/$USER}
export SHELL='/bin/zsh'

# color setup for ls:
check_com -c dircolors && eval $(dircolors -b)
# color setup for ls on OS X:
isdarwin && export CLICOLOR=1


# load our function and completion directories
for fdir in /usr/share/grml/zsh/completion /usr/share/grml/zsh/functions; do
    fpath=( ${fdir} ${fdir}/**/*(/N) ${fpath} )
    if [[ ${fpath} == '/usr/share/grml/zsh/functions' ]] ; then
        for func in ${fdir}/**/[^_]*[^~](N.) ; do
            zrcautoload ${func:t}
        done
    fi
done
unset fdir func

# support colors in less
export LESS_TERMCAP_mb=$'\E[01;31m'
export LESS_TERMCAP_md=$'\E[01;31m'
export LESS_TERMCAP_me=$'\E[0m'
export LESS_TERMCAP_se=$'\E[0m'
export LESS_TERMCAP_so=$'\E[01;44;33m'
export LESS_TERMCAP_ue=$'\E[0m'
export LESS_TERMCAP_us=$'\E[01;32m'

REPORTTIME=5       # report about cpu-/system-/user-time of command if running longer than 5 seconds
watch=(notme root) # watch for everyone but me and root

# automatically remove duplicates from these arrays
typeset -U path cdpath fpath manpath

## toggle the ,. abbreviation feature on/off
# NOABBREVIATION: default abbreviation-state
#                 0 - enabled (default)
#                 1 - disabled
NOABBREVIATION=${NOABBREVIATION:-0}

# power completion / abbreviation expansion / buffer expansion
# see http://zshwiki.org/home/examples/zleiab for details
# less risky than the global aliases but powerful as well
# just type the abbreviation key and afterwards ',.' to expand it
declare -A abk
setopt extendedglob
setopt interactivecomments
abk=(
#   key   # value                  (#d additional doc string)
#A# start
    '...'  '../..'
    '....' '../../..'
    'BG'   '& exit'
    'C'    '| wc -l'
    'G'    '|& grep --color=auto '
    'H'    '| head'
    'Hl'   ' --help |& less -r'    #d (Display help in pager)
    'L'    '| less'
    'LL'   '|& less -r'
    'M'    '| most'
    'N'    '&>/dev/null'           #d (No Output)
    'R'    '| tr A-z N-za-m'       #d (ROT13)
    'SL'   '| sort | less'
    'S'    '| sort -u'
    'T'    '| tail'
    'V'    '|& vim -'
#A# end
    'co'   './configure && make && sudo make install'
)



# autoloading
zrcautoload zmv    # who needs mmv or rename?
zrcautoload history-search-end


# completion system
if zrcautoload compinit ; then
    compinit || print 'Notice: no compinit available :('
else
    print 'Notice: no compinit available :('
    function zstyle { }
    function compdef { }
fi

is4 && zrcautoload zed # use ZLE editor to edit a file or function

is4 && \
for mod in complist deltochar mathfunc ; do
    zmodload -i zsh/${mod} 2>/dev/null || print "Notice: no ${mod} available :("
done

# autoload zsh modules when they are referenced
if is4 ; then
    zmodload -a  zsh/stat    zstat
    zmodload -a  zsh/zpty    zpty
    zmodload -ap zsh/mapfile mapfile
fi

DIRSTACKSIZE=${DIRSTACKSIZE:-20}
DIRSTACKFILE=${DIRSTACKFILE:-${HOME}/.zdirs}

if [[ -f ${DIRSTACKFILE} ]] && [[ ${#dirstack[*]} -eq 0 ]] ; then
    dirstack=( ${(f)"$(< $DIRSTACKFILE)"} )
    # "cd -" won't work after login by just setting $OLDPWD, so
    [[ -d $dirstack[0] ]] && cd $dirstack[0] && cd $OLDPWD
fi

# display battery status on right side of prompt via running 'BATTERY=1 zsh'
if [[ $BATTERY -gt 0 ]] ; then
    if ! check_com -c acpi ; then
        BATTERY=0
    fi
fi


# set colors for use in prompts
if zrcautoload colors && colors 2>/dev/null ; then
    BLUE="%{${fg[blue]}%}"
    BOLD_BLUE="%{${fg_bold[blue]}%}"
    RED="%{${fg[red]}%}"
    BOLD_RED="%{${fg_bold[red]}%}"
    GREEN="%{${fg[green]}%}"
    CYAN="%{${fg[cyan]}%}"
    BOLD_CYAN="%{${fg_bold[cyan]}%}"
    MAGENTA="%{${fg[magenta]}%}"
    YELLOW="%{${fg[yellow]}%}"
    WHITE="%{${fg[white]}%}"
    NO_COLOUR="%{${reset_color}%}"
else
    BLUE=$'%{\e[1;34m%}'
    RED=$'%{\e[1;31m%}'
    GREEN=$'%{\e[1;32m%}'
    CYAN=$'%{\e[1;36m%}'
    WHITE=$'%{\e[1;37m%}'
    MAGENTA=$'%{\e[1;35m%}'
    YELLOW=$'%{\e[1;33m%}'
    NO_COLOUR=$'%{\e[0m%}'
fi

# set prompt
if zrcautoload promptinit && promptinit 2>/dev/null ; then
    promptinit # people should be able to use their favourite prompt
else
    print 'Notice: no promptinit available :('
fi

setopt prompt_subst

# make sure to use right prompt only when not running a command
is41 && setopt transient_rprompt

is4 && autoload -Uz vcs_info # Autoload vcs_info for
                             # vcs information in prompt

zstyle ':vcs_info:*' stagedstr '%F{3}●'
#zstyle ':vcs_info:*' stagedstr ' [%F{green}%b%c%u%F{blue}]'
#zstyle ':vcs_info:*' unstagedstr '[%F{green}%b%c%u%F{red}●%F{blue}]'
zstyle ':vcs_info:*' unstagedstr '%F{2}●'
zstyle ':vcs_info:*' check-for-changes true
zstyle ':vcs_info:(sv[nk]|bzr):*' branchformat '%b%F{1}:%F{11}%r'
zstyle ':vcs_info:*' enable git svn hg


is4 && [[ $NOPRECMD -eq 0 ]] && \
precmd () {
    [[ $NOPRECMD -gt 0 ]] && return 0
    # update VCS information
    if [[ -z $(git ls-files --other --exclude-standard 2> /dev/null) ]] {
        zstyle ':vcs_info:*' formats '[%F{green}%b%c%u%F{blue}]'
    } else {
        zstyle ':vcs_info:*' formats '[%F{green}%b%c%u%F{red}●%F{blue}]'
    }
    vcs_info

    if [[ $TERM == screen* ]] ; then
        if [[ -n ${VCS_INFO_message_1_} ]] ; then
            ESC_print ${VCS_INFO_message_1_}
        elif [[ -n ${vcs_info_msg_1_} ]] ; then
            ESC_print ${vcs_info_msg_1_}
        else
            ESC_print "zsh"
        fi
    fi
    # just use DONTSETRPROMPT=1 to be able to overwrite RPROMPT
    if [[ $DONTSETRPROMPT -eq 0 ]] ; then
        if [[ $BATTERY -gt 0 ]] ; then
            # update battery (dropped into $PERCENT) information
            battery
            RPROMPT="%(?..:() ${PERCENT}"
        else
            RPROMPT="%(?..:() "
        fi
    fi
    # adjust title of xterm
    # see http://www.faqs.org/docs/Linux-mini/Xterm-Title.html
    [[ ${NOTITLE} -gt 0 ]] && return 0
    case $TERM in
        (xterm*|rxvt*)
            set_title ${(%):-"%n@%m: %~"}
            # echo -ne "\ek$(basename "$(pwd)")/\e\\"
            echo -n "\ek${(%):-"%~"}\e\\"
            ;;
        (screen*)
            set_title ${(%):-"%n@%m: %~"}
            echo -n "\ek${(%):-"%~"}\e\\"
            ;;
    esac
}

# preexec() => a function running before every command
is4 && [[ $NOPRECMD -eq 0 ]] && \
preexec () {
    [[ $NOPRECMD -gt 0 ]] && return 0

    # set hostname
    if [[ -n "$HOSTNAME" ]] && [[ "$HOSTNAME" != $(hostname) ]] ; then
       NAME="@$HOSTNAME"
    fi

    # adjust title of xterm/rxvt
    [[ ${NOTITLE} -gt 0 ]] && return 0
    case $TERM in
        (xterm*|rxvt*)
            set_title "${(%):-"%n@%m:"}" "$1" ;;
        (screen*)
            set_title "${(%):-"%n@%m:"}" "$1"
            echo -n "\ek${(%):-"$1"}\e\\"
            ;;
    esac
}

EXITCODE="%(?..%?%1v )"
PS2='\`%_> '      # secondary prompt, printed when the shell needs more information to complete a command.
PS3='?# '         # selection prompt used within a select loop.
PS4='+%N:%i:%_> ' # the execution trace prompt (setopt xtrace). default: '+%N:%i>'

# don't use colors on dumb terminals (like emacs):
if [[ "$TERM" == dumb ]] ; then
    PROMPT="${EXITCODE} %n@%m %40<...<%B%~%b%<< "
else
    if [[ $(command id -u) -eq 0 ]] ; then
        P_EXIT="${RED}${EXITCODE}"
        P_USER='${RED}%n${NO_COLOUR}'
        P_AT='@'
        P_HOST='${YELLOW}%m'
        P_CWD=' ${BOLD_CYAN}%40<...<%B%~%b%<< '
        #PROMPT="${PROMPT}"'${RED}%n${NO_COLOUR}@${YELLOW}%m ${BOLD_CYAN}%40<...<%B%~%b%<< '
        PROMPT="${PROMPT}${P_EXIT}${P_USER}${P_AT}${P_HOST}${P_CWD}"
    else
        PROMPT="${RED}${EXITCODE}"
        PROMPT="${PROMPT}"'${MAGENTA}%n${NO_COLOUR}@${YELLOW}%m ${BOLD_CYAN}%40<...<%B%~%b%<< '
    fi
fi

if (( GRML_VCS_INFO )); then
    PROMPT="${PROMPT}${BLUE}"'${VCS_INFO_message_0_}'"${NO_COLOUR}%# "
else
    PROMPT="${PROMPT}${BLUE}"'${vcs_info_msg_0_}'"${NO_COLOUR}%# "
fi


# Use hard limits, except for a smaller stack and no core dumps
unlimit
is425 && limit stack 8192

# Start completion system
NOMENU=1 # No menu completion puh-leeeze.
is4 && grmlcomp

zrcautoload lookupinit && lookupinit

# set terminal property (used e.g. by msgid-chooser)
export COLORTERM="yes"

# executed for interactive shells

if [ -f ~/.config/ssh-agent ]; then
    source ~/.config/ssh-agent
fi

if [ -z "$SSH_AUTH_SOCK" ] || [ ! -w "$SSH_AUTH_SOCK" ]; then
        ssh-agent -s > ~/.config/ssh-agent              && \
            source ~/.config/ssh-agent                  && \
            ssh-add
fi

source-host-config
